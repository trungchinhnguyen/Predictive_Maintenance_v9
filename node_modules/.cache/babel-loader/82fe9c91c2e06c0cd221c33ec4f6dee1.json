{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\n\nexport const registerBackend = (name, backend, priority) => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    const currentBackend = backends[name];\n\n    if (currentBackend === undefined) {\n      backends[name] = {\n        backend,\n        priority\n      };\n    } else if (currentBackend.backend === backend) {\n      return;\n    } else {\n      throw new Error(`backend \"${name}\" is already registered`);\n    }\n\n    if (priority >= 0) {\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n\n      backendsSortedByPriority.push(name);\n    }\n\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\n\nexport const resolveBackend = async backendHints => {\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n  const errors = [];\n\n  for (const backendName of backendNames) {\n    const backendInfo = backends[backendName];\n\n    if (backendInfo) {\n      if (backendInfo.initialized) {\n        return backendInfo.backend;\n      } else if (backendInfo.aborted) {\n        continue; // current backend is unavailable; try next\n      }\n\n      const isInitializing = !!backendInfo.initPromise;\n\n      try {\n        if (!isInitializing) {\n          backendInfo.initPromise = backendInfo.backend.init();\n        }\n\n        await backendInfo.initPromise;\n        backendInfo.initialized = true;\n        return backendInfo.backend;\n      } catch (e) {\n        if (!isInitializing) {\n          errors.push({\n            name: backendName,\n            err: e\n          });\n        }\n\n        backendInfo.aborted = true;\n      } finally {\n        delete backendInfo.initPromise;\n      }\n    }\n  }\n\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};","map":{"version":3,"mappings":"AAAA;AACA;AAaA,MAAMA,QAAQ,GAAkC,EAAhD;AACA,MAAMC,wBAAwB,GAAa,EAA3C;AAEA;;;;;;;;;;;AAUA,OAAO,MAAMC,eAAe,GAAG,CAACC,IAAD,EAAeC,OAAf,EAAiCC,QAAjC,KAA2D;EACxF,IAAID,OAAO,IAAI,OAAOA,OAAO,CAACE,IAAf,KAAwB,UAAnC,IAAiD,OAAOF,OAAO,CAACG,oBAAf,KAAwC,UAA7F,EAAyG;IACvG,MAAMC,cAAc,GAAGR,QAAQ,CAACG,IAAD,CAA/B;;IACA,IAAIK,cAAc,KAAKC,SAAvB,EAAkC;MAChCT,QAAQ,CAACG,IAAD,CAAR,GAAiB;QAACC,OAAD;QAAUC;MAAV,CAAjB;IACD,CAFD,MAEO,IAAIG,cAAc,CAACJ,OAAf,KAA2BA,OAA/B,EAAwC;MAC7C;IACD,CAFM,MAEA;MACL,MAAM,IAAIM,KAAJ,CAAU,YAAYP,IAAI,yBAA1B,CAAN;IACD;;IAED,IAAIE,QAAQ,IAAI,CAAhB,EAAmB;MACjB,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,wBAAwB,CAACW,MAA7C,EAAqDD,CAAC,EAAtD,EAA0D;QACxD,IAAIX,QAAQ,CAACC,wBAAwB,CAACU,CAAD,CAAzB,CAAR,CAAsCN,QAAtC,IAAkDA,QAAtD,EAAgE;UAC9DJ,wBAAwB,CAACY,MAAzB,CAAgCF,CAAhC,EAAmC,CAAnC,EAAsCR,IAAtC;UACA;QACD;MACF;;MACDF,wBAAwB,CAACa,IAAzB,CAA8BX,IAA9B;IACD;;IACD;EACD;;EAED,MAAM,IAAIY,SAAJ,CAAc,qBAAd,CAAN;AACD,CAxBM;AA0BP;;;;;;;;;AAQA,OAAO,MAAMC,cAAc,GAAG,MAAMC,YAAN,IAA2D;EACvF,MAAMC,YAAY,GAAGD,YAAY,CAACL,MAAb,KAAwB,CAAxB,GAA4BX,wBAA5B,GAAuDgB,YAA5E;EACA,MAAME,MAAM,GAAG,EAAf;;EACA,KAAK,MAAMC,WAAX,IAA0BF,YAA1B,EAAwC;IACtC,MAAMG,WAAW,GAAGrB,QAAQ,CAACoB,WAAD,CAA5B;;IACA,IAAIC,WAAJ,EAAiB;MACf,IAAIA,WAAW,CAACC,WAAhB,EAA6B;QAC3B,OAAOD,WAAW,CAACjB,OAAnB;MACD,CAFD,MAEO,IAAIiB,WAAW,CAACE,OAAhB,EAAyB;QAC9B,SAD8B,CACnB;MACZ;;MAED,MAAMC,cAAc,GAAG,CAAC,CAACH,WAAW,CAACI,WAArC;;MACA,IAAI;QACF,IAAI,CAACD,cAAL,EAAqB;UACnBH,WAAW,CAACI,WAAZ,GAA0BJ,WAAW,CAACjB,OAAZ,CAAoBE,IAApB,EAA1B;QACD;;QACD,MAAMe,WAAW,CAACI,WAAlB;QACAJ,WAAW,CAACC,WAAZ,GAA0B,IAA1B;QACA,OAAOD,WAAW,CAACjB,OAAnB;MACD,CAPD,CAOE,OAAOsB,CAAP,EAAU;QACV,IAAI,CAACF,cAAL,EAAqB;UACnBL,MAAM,CAACL,IAAP,CAAY;YAACX,IAAI,EAAEiB,WAAP;YAAoBO,GAAG,EAAED;UAAzB,CAAZ;QACD;;QACDL,WAAW,CAACE,OAAZ,GAAsB,IAAtB;MACD,CAZD,SAYU;QACR,OAAOF,WAAW,CAACI,WAAnB;MACD;IACF;EACF;;EAED,MAAM,IAAIf,KAAJ,CAAU,oCAAoCS,MAAM,CAACS,GAAP,CAAWF,CAAC,IAAI,IAAIA,CAAC,CAACvB,IAAI,KAAKuB,CAAC,CAACC,GAAG,EAApC,EAAwCE,IAAxC,CAA6C,IAA7C,CAAkD,EAAhG,CAAN;AACD,CAhCM","names":["backends","backendsSortedByPriority","registerBackend","name","backend","priority","init","createSessionHandler","currentBackend","undefined","Error","i","length","splice","push","TypeError","resolveBackend","backendHints","backendNames","errors","backendName","backendInfo","initialized","aborted","isInitializing","initPromise","e","err","map","join"],"sources":["/Users/nguyentrungchinh/project_20/node_modules/onnxruntime-common/lib/backend-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {Backend} from './backend';\r\n\r\ninterface BackendInfo {\r\n  backend: Backend;\r\n  priority: number;\r\n\r\n  initPromise?: Promise<void>;\r\n  initialized?: boolean;\r\n  aborted?: boolean;\r\n}\r\n\r\nconst backends: {[name: string]: BackendInfo} = {};\r\nconst backendsSortedByPriority: string[] = [];\r\n\r\n/**\r\n * Register a backend.\r\n *\r\n * @param name - the name as a key to lookup as an execution provider.\r\n * @param backend - the backend object.\r\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\r\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\r\n *\r\n * @internal\r\n */\r\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\r\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\r\n    const currentBackend = backends[name];\r\n    if (currentBackend === undefined) {\r\n      backends[name] = {backend, priority};\r\n    } else if (currentBackend.backend === backend) {\r\n      return;\r\n    } else {\r\n      throw new Error(`backend \"${name}\" is already registered`);\r\n    }\r\n\r\n    if (priority >= 0) {\r\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\r\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\r\n          backendsSortedByPriority.splice(i, 0, name);\r\n          return;\r\n        }\r\n      }\r\n      backendsSortedByPriority.push(name);\r\n    }\r\n    return;\r\n  }\r\n\r\n  throw new TypeError('not a valid backend');\r\n};\r\n\r\n/**\r\n * Resolve backend by specified hints.\r\n *\r\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\r\n * @returns a promise that resolves to the backend.\r\n *\r\n * @internal\r\n */\r\nexport const resolveBackend = async(backendHints: readonly string[]): Promise<Backend> => {\r\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\r\n  const errors = [];\r\n  for (const backendName of backendNames) {\r\n    const backendInfo = backends[backendName];\r\n    if (backendInfo) {\r\n      if (backendInfo.initialized) {\r\n        return backendInfo.backend;\r\n      } else if (backendInfo.aborted) {\r\n        continue;  // current backend is unavailable; try next\r\n      }\r\n\r\n      const isInitializing = !!backendInfo.initPromise;\r\n      try {\r\n        if (!isInitializing) {\r\n          backendInfo.initPromise = backendInfo.backend.init();\r\n        }\r\n        await backendInfo.initPromise;\r\n        backendInfo.initialized = true;\r\n        return backendInfo.backend;\r\n      } catch (e) {\r\n        if (!isInitializing) {\r\n          errors.push({name: backendName, err: e});\r\n        }\r\n        backendInfo.aborted = true;\r\n      } finally {\r\n        delete backendInfo.initPromise;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}