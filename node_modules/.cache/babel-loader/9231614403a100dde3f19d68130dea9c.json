{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nguyentrungchinh/project_20/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/nguyentrungchinh/project_20/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/nguyentrungchinh/project_20/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/nguyentrungchinh/project_20/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nguyentrungchinh/project_20/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { resolveBackend } from './backend-impl';\nimport { Tensor } from './tensor';\nexport var InferenceSession = /*#__PURE__*/function () {\n  function InferenceSession(handler) {\n    _classCallCheck(this, InferenceSession);\n\n    this.handler = handler;\n  }\n\n  _createClass(InferenceSession, [{\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(feeds, arg1, arg2) {\n        var fetches, options, isFetchesEmpty, _iterator, _step, name, isFetches, arg1Keys, _iterator2, _step2, _name, v, _iterator3, _step3, _name3, _iterator4, _step4, _name2, results, returnValue, key;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                fetches = {};\n                options = {}; // check inputs\n\n                if (!(typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds))) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n\n              case 4:\n                isFetchesEmpty = true; // determine which override is being used\n\n                if (!(typeof arg1 === 'object')) {\n                  _context.next = 58;\n                  break;\n                }\n\n                if (!(arg1 === null)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n\n              case 8:\n                if (!(arg1 instanceof Tensor)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new TypeError('\\'fetches\\' cannot be a Tensor');\n\n              case 10:\n                if (!Array.isArray(arg1)) {\n                  _context.next = 42;\n                  break;\n                }\n\n                if (!(arg1.length === 0)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new TypeError('\\'fetches\\' cannot be an empty array.');\n\n              case 13:\n                isFetchesEmpty = false; // output names\n\n                _iterator = _createForOfIteratorHelper(arg1);\n                _context.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 26;\n                  break;\n                }\n\n                name = _step.value;\n\n                if (!(typeof name !== 'string')) {\n                  _context.next = 21;\n                  break;\n                }\n\n                throw new TypeError('\\'fetches\\' must be a string array or an object.');\n\n              case 21:\n                if (!(this.outputNames.indexOf(name) === -1)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                throw new RangeError(\"'fetches' contains invalid output name: \".concat(name, \".\"));\n\n              case 23:\n                fetches[name] = null;\n\n              case 24:\n                _context.next = 17;\n                break;\n\n              case 26:\n                _context.next = 31;\n                break;\n\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](15);\n\n                _iterator.e(_context.t0);\n\n              case 31:\n                _context.prev = 31;\n\n                _iterator.f();\n\n                return _context.finish(31);\n\n              case 34:\n                if (!(typeof arg2 === 'object' && arg2 !== null)) {\n                  _context.next = 38;\n                  break;\n                }\n\n                options = arg2;\n                _context.next = 40;\n                break;\n\n              case 38:\n                if (!(typeof arg2 !== 'undefined')) {\n                  _context.next = 40;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 40:\n                _context.next = 56;\n                break;\n\n              case 42:\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                isFetches = false;\n                arg1Keys = Object.getOwnPropertyNames(arg1);\n                _iterator2 = _createForOfIteratorHelper(this.outputNames);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _name = _step2.value;\n\n                    if (arg1Keys.indexOf(_name) !== -1) {\n                      v = arg1[_name];\n\n                      if (v === null || v instanceof Tensor) {\n                        isFetches = true;\n                        isFetchesEmpty = false;\n                        fetches[_name] = v;\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                if (!isFetches) {\n                  _context.next = 55;\n                  break;\n                }\n\n                if (!(typeof arg2 === 'object' && arg2 !== null)) {\n                  _context.next = 51;\n                  break;\n                }\n\n                options = arg2;\n                _context.next = 53;\n                break;\n\n              case 51:\n                if (!(typeof arg2 !== 'undefined')) {\n                  _context.next = 53;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 53:\n                _context.next = 56;\n                break;\n\n              case 55:\n                options = arg1;\n\n              case 56:\n                _context.next = 60;\n                break;\n\n              case 58:\n                if (!(typeof arg1 !== 'undefined')) {\n                  _context.next = 60;\n                  break;\n                }\n\n                throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n\n              case 60:\n                // check if all inputs are in feed\n                _iterator3 = _createForOfIteratorHelper(this.inputNames);\n                _context.prev = 61;\n\n                _iterator3.s();\n\n              case 63:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context.next = 69;\n                  break;\n                }\n\n                _name3 = _step3.value;\n\n                if (!(typeof feeds[_name3] === 'undefined')) {\n                  _context.next = 67;\n                  break;\n                }\n\n                throw new Error(\"input '\".concat(_name3, \"' is missing in 'feeds'.\"));\n\n              case 67:\n                _context.next = 63;\n                break;\n\n              case 69:\n                _context.next = 74;\n                break;\n\n              case 71:\n                _context.prev = 71;\n                _context.t1 = _context[\"catch\"](61);\n\n                _iterator3.e(_context.t1);\n\n              case 74:\n                _context.prev = 74;\n\n                _iterator3.f();\n\n                return _context.finish(74);\n\n              case 77:\n                // if no fetches is specified, we use the full output names list\n                if (isFetchesEmpty) {\n                  _iterator4 = _createForOfIteratorHelper(this.outputNames);\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      _name2 = _step4.value;\n                      fetches[_name2] = null;\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                } // feeds, fetches and options are prepared\n\n\n                _context.next = 80;\n                return this.handler.run(feeds, fetches, options);\n\n              case 80:\n                results = _context.sent;\n                returnValue = {};\n\n                for (key in results) {\n                  if (Object.hasOwnProperty.call(results, key)) {\n                    returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n                  }\n                }\n\n                return _context.abrupt(\"return\", returnValue);\n\n              case 84:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[15, 28, 31, 34], [61, 71, 74, 77]]);\n      }));\n\n      function run(_x, _x2, _x3) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: \"startProfiling\",\n    value: function startProfiling() {\n      this.handler.startProfiling();\n    }\n  }, {\n    key: \"endProfiling\",\n    value: function endProfiling() {\n      this.handler.endProfiling();\n    }\n  }, {\n    key: \"inputNames\",\n    get: function get() {\n      return this.handler.inputNames;\n    }\n  }, {\n    key: \"outputNames\",\n    get: function get() {\n      return this.handler.outputNames;\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(arg0, arg1, arg2, arg3) {\n        var filePathOrUint8Array, options, buffer, byteOffset, byteLength, eps, backendHints, backend, handler;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // either load from a file or buffer\n                options = {};\n\n                if (!(typeof arg0 === 'string')) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                filePathOrUint8Array = arg0;\n\n                if (!(typeof arg1 === 'object' && arg1 !== null)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                options = arg1;\n                _context2.next = 9;\n                break;\n\n              case 7:\n                if (!(typeof arg1 !== 'undefined')) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 9:\n                _context2.next = 60;\n                break;\n\n              case 11:\n                if (!(arg0 instanceof Uint8Array)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                filePathOrUint8Array = arg0;\n\n                if (!(typeof arg1 === 'object' && arg1 !== null)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                options = arg1;\n                _context2.next = 19;\n                break;\n\n              case 17:\n                if (!(typeof arg1 !== 'undefined')) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 19:\n                _context2.next = 60;\n                break;\n\n              case 21:\n                if (!(arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n                  _context2.next = 59;\n                  break;\n                }\n\n                buffer = arg0;\n                byteOffset = 0;\n                byteLength = arg0.byteLength;\n\n                if (!(typeof arg1 === 'object' && arg1 !== null)) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                options = arg1;\n                _context2.next = 56;\n                break;\n\n              case 29:\n                if (!(typeof arg1 === 'number')) {\n                  _context2.next = 54;\n                  break;\n                }\n\n                byteOffset = arg1;\n\n                if (Number.isSafeInteger(byteOffset)) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                throw new RangeError('\\'byteOffset\\' must be an integer.');\n\n              case 33:\n                if (!(byteOffset < 0 || byteOffset >= buffer.byteLength)) {\n                  _context2.next = 35;\n                  break;\n                }\n\n                throw new RangeError(\"'byteOffset' is out of range [0, \".concat(buffer.byteLength, \").\"));\n\n              case 35:\n                byteLength = arg0.byteLength - byteOffset;\n\n                if (!(typeof arg2 === 'number')) {\n                  _context2.next = 50;\n                  break;\n                }\n\n                byteLength = arg2;\n\n                if (Number.isSafeInteger(byteLength)) {\n                  _context2.next = 40;\n                  break;\n                }\n\n                throw new RangeError('\\'byteLength\\' must be an integer.');\n\n              case 40:\n                if (!(byteLength <= 0 || byteOffset + byteLength > buffer.byteLength)) {\n                  _context2.next = 42;\n                  break;\n                }\n\n                throw new RangeError(\"'byteLength' is out of range (0, \".concat(buffer.byteLength - byteOffset, \"].\"));\n\n              case 42:\n                if (!(typeof arg3 === 'object' && arg3 !== null)) {\n                  _context2.next = 46;\n                  break;\n                }\n\n                options = arg3;\n                _context2.next = 48;\n                break;\n\n              case 46:\n                if (!(typeof arg3 !== 'undefined')) {\n                  _context2.next = 48;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 48:\n                _context2.next = 52;\n                break;\n\n              case 50:\n                if (!(typeof arg2 !== 'undefined')) {\n                  _context2.next = 52;\n                  break;\n                }\n\n                throw new TypeError('\\'byteLength\\' must be a number.');\n\n              case 52:\n                _context2.next = 56;\n                break;\n\n              case 54:\n                if (!(typeof arg1 !== 'undefined')) {\n                  _context2.next = 56;\n                  break;\n                }\n\n                throw new TypeError('\\'options\\' must be an object.');\n\n              case 56:\n                filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n                _context2.next = 60;\n                break;\n\n              case 59:\n                throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n\n              case 60:\n                // get backend hints\n                eps = options.executionProviders || [];\n                backendHints = eps.map(function (i) {\n                  return typeof i === 'string' ? i : i.name;\n                });\n                _context2.next = 64;\n                return resolveBackend(backendHints);\n\n              case 64:\n                backend = _context2.sent;\n                _context2.next = 67;\n                return backend.createSessionHandler(filePathOrUint8Array, options);\n\n              case 67:\n                handler = _context2.sent;\n                return _context2.abrupt(\"return\", new InferenceSession(handler));\n\n              case 69:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function create(_x4, _x5, _x6, _x7) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return InferenceSession;\n}();","map":{"version":3,"mappings":";;;;;AAAA;AACA;AAGA,SAAQA,cAAR,QAA6B,gBAA7B;AAGA,SAAQC,MAAR,QAAqB,UAArB;AAQA,WAAaC,gBAAb;EACE,0BAAoBC,OAApB,EAA2C;IAAA;;IACzC,KAAKA,OAAL,GAAeA,OAAf;EACD;;EAHH;IAAA;IAAA;MAAA,sEAME,iBAAUC,KAAV,EAA4BC,IAA5B,EAA2DC,IAA3D;QAAA;;QAAA;UAAA;YAAA;cAAA;gBACQC,OADR,GACoD,EADpD;gBAEMC,OAFN,GAE4B,EAF5B,EAGE;;gBAHF,MAIM,OAAOJ,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+CA,KAAK,YAAYH,MAAhE,IAA0EQ,KAAK,CAACC,OAAN,CAAcN,KAAd,CAJhF;kBAAA;kBAAA;gBAAA;;gBAAA,MAKU,IAAIO,SAAJ,CACF,iGADE,CALV;;cAAA;gBASMC,cATN,GASuB,IATvB,EAUE;;gBAVF,MAWM,OAAOP,IAAP,KAAgB,QAXtB;kBAAA;kBAAA;gBAAA;;gBAAA,MAYQA,IAAI,KAAK,IAZjB;kBAAA;kBAAA;gBAAA;;gBAAA,MAaY,IAAIM,SAAJ,CAAc,yCAAd,CAbZ;;cAAA;gBAAA,MAeQN,IAAI,YAAYJ,MAfxB;kBAAA;kBAAA;gBAAA;;gBAAA,MAgBY,IAAIU,SAAJ,CAAc,gCAAd,CAhBZ;;cAAA;gBAAA,KAmBQF,KAAK,CAACC,OAAN,CAAcL,IAAd,CAnBR;kBAAA;kBAAA;gBAAA;;gBAAA,MAoBUA,IAAI,CAACQ,MAAL,KAAgB,CApB1B;kBAAA;kBAAA;gBAAA;;gBAAA,MAqBc,IAAIF,SAAJ,CAAc,uCAAd,CArBd;;cAAA;gBAuBMC,cAAc,GAAG,KAAjB,CAvBN,CAwBM;;gBAxBN,uCAyByBP,IAzBzB;gBAAA;;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBAyBiBS,IAzBjB;;gBAAA,MA0BY,OAAOA,IAAP,KAAgB,QA1B5B;kBAAA;kBAAA;gBAAA;;gBAAA,MA2BgB,IAAIH,SAAJ,CAAc,kDAAd,CA3BhB;;cAAA;gBAAA,MA6BY,KAAKI,WAAL,CAAiBC,OAAjB,CAAyBF,IAAzB,MAAmC,CAAC,CA7BhD;kBAAA;kBAAA;gBAAA;;gBAAA,MA8BgB,IAAIG,UAAJ,mDAA0DH,IAA1D,OA9BhB;;cAAA;gBAgCQP,OAAO,CAACO,IAAD,CAAP,GAAgB,IAAhB;;cAhCR;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;gBAAA;;gBAAA;;cAAA;gBAAA,MAmCU,OAAOR,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAnC/C;kBAAA;kBAAA;gBAAA;;gBAoCQE,OAAO,GAAGF,IAAV;gBApCR;gBAAA;;cAAA;gBAAA,MAqCiB,OAAOA,IAAP,KAAgB,WArCjC;kBAAA;kBAAA;gBAAA;;gBAAA,MAsCc,IAAIK,SAAJ,CAAc,gCAAd,CAtCd;;cAAA;gBAAA;gBAAA;;cAAA;gBAyCM;gBACA;gBACIO,SA3CV,GA2CsB,KA3CtB;gBA4CYC,QA5CZ,GA4CuBC,MAAM,CAACC,mBAAP,CAA2BhB,IAA3B,CA5CvB;gBAAA,wCA6CyB,KAAKU,WA7C9B;;gBAAA;kBA6CM,uDAAqC;oBAA1BD,KAA0B;;oBACnC,IAAIK,QAAQ,CAACH,OAAT,CAAiBF,KAAjB,MAA2B,CAAC,CAAhC,EAAmC;sBAC3BQ,CAD2B,GACtBjB,IAA2D,CAACS,KAAD,CADrC;;sBAEjC,IAAIQ,CAAC,KAAK,IAAN,IAAcA,CAAC,YAAYrB,MAA/B,EAAuC;wBACrCiB,SAAS,GAAG,IAAZ;wBACAN,cAAc,GAAG,KAAjB;wBACAL,OAAO,CAACO,KAAD,CAAP,GAAgBQ,CAAhB;sBACD;oBACF;kBACF;gBAtDP;kBAAA;gBAAA;kBAAA;gBAAA;;gBAAA,KAwDUJ,SAxDV;kBAAA;kBAAA;gBAAA;;gBAAA,MAyDY,OAAOZ,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAzDjD;kBAAA;kBAAA;gBAAA;;gBA0DUE,OAAO,GAAGF,IAAV;gBA1DV;gBAAA;;cAAA;gBAAA,MA2DmB,OAAOA,IAAP,KAAgB,WA3DnC;kBAAA;kBAAA;gBAAA;;gBAAA,MA4DgB,IAAIK,SAAJ,CAAc,gCAAd,CA5DhB;;cAAA;gBAAA;gBAAA;;cAAA;gBA+DQH,OAAO,GAAGH,IAAV;;cA/DR;gBAAA;gBAAA;;cAAA;gBAAA,MAkEa,OAAOA,IAAP,KAAgB,WAlE7B;kBAAA;kBAAA;gBAAA;;gBAAA,MAmEU,IAAIM,SAAJ,CAAc,6DAAd,CAnEV;;cAAA;gBAsEE;gBAtEF,wCAuEqB,KAAKY,UAvE1B;gBAAA;;gBAAA;;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;;gBAuEaT,MAvEb;;gBAAA,MAwEQ,OAAOV,KAAK,CAACU,MAAD,CAAZ,KAAuB,WAxE/B;kBAAA;kBAAA;gBAAA;;gBAAA,MAyEY,IAAIU,KAAJ,kBAAoBV,MAApB,8BAzEZ;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA;gBAAA;;gBAAA;;cAAA;gBAAA;;gBAAA;;gBAAA;;cAAA;gBA6EE;gBACA,IAAIF,cAAJ,EAAoB;kBAAA,wCACC,KAAKG,WADN;;kBAAA;oBAClB,uDAAqC;sBAA1BD,MAA0B;sBACnCP,OAAO,CAACO,MAAD,CAAP,GAAgB,IAAhB;oBACD;kBAHiB;oBAAA;kBAAA;oBAAA;kBAAA;gBAInB,CAlFH,CAoFE;;;gBApFF;gBAAA,OAsFwB,KAAKX,OAAL,CAAasB,GAAb,CAAiBrB,KAAjB,EAAwBG,OAAxB,EAAiCC,OAAjC,CAtFxB;;cAAA;gBAsFQkB,OAtFR;gBAuFQC,WAvFR,GAuFmD,EAvFnD;;gBAwFE,KAAWC,GAAX,IAAkBF,OAAlB,EAA2B;kBACzB,IAAIN,MAAM,CAACS,cAAP,CAAsBC,IAAtB,CAA2BJ,OAA3B,EAAoCE,GAApC,CAAJ,EAA8C;oBAC5CD,WAAW,CAACC,GAAD,CAAX,GAAmB,IAAI3B,MAAJ,CAAWyB,OAAO,CAACE,GAAD,CAAP,CAAaG,IAAxB,EAA8BL,OAAO,CAACE,GAAD,CAAP,CAAaI,IAA3C,EAAiDN,OAAO,CAACE,GAAD,CAAP,CAAaK,IAA9D,CAAnB;kBACD;gBACF;;gBA5FH,iCA6FSN,WA7FT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CANF;;MAAA;QAAA;MAAA;;MAAA;IAAA;EAAA;IAAA;IAAA,OAiLE,0BAAc;MACZ,KAAKxB,OAAL,CAAa+B,cAAb;IACD;EAnLH;IAAA;IAAA,OAoLE,wBAAY;MACV,KAAK/B,OAAL,CAAagC,YAAb;IACD;EAtLH;IAAA;IAAA,KAwLE,eAAc;MACZ,OAAO,KAAKhC,OAAL,CAAaoB,UAApB;IACD;EA1LH;IAAA;IAAA,KA2LE,eAAe;MACb,OAAO,KAAKpB,OAAL,CAAaY,WAApB;IACD;EA7LH;IAAA;IAAA;MAAA,yEA2GE,kBACIqB,IADJ,EAC6C/B,IAD7C,EAC2EC,IAD3E,EAEI+B,IAFJ;QAAA;QAAA;UAAA;YAAA;cAAA;gBAGE;gBAEI7B,OALN,GAKgC,EALhC;;gBAAA,MAOM,OAAO4B,IAAP,KAAgB,QAPtB;kBAAA;kBAAA;gBAAA;;gBAQIE,oBAAoB,GAAGF,IAAvB;;gBARJ,MASQ,OAAO/B,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAT7C;kBAAA;kBAAA;gBAAA;;gBAUMG,OAAO,GAAGH,IAAV;gBAVN;gBAAA;;cAAA;gBAAA,MAWe,OAAOA,IAAP,KAAgB,WAX/B;kBAAA;kBAAA;gBAAA;;gBAAA,MAYY,IAAIM,SAAJ,CAAc,gCAAd,CAZZ;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA,MAcayB,IAAI,YAAYG,UAd7B;kBAAA;kBAAA;gBAAA;;gBAeID,oBAAoB,GAAGF,IAAvB;;gBAfJ,MAgBQ,OAAO/B,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAhB7C;kBAAA;kBAAA;gBAAA;;gBAiBMG,OAAO,GAAGH,IAAV;gBAjBN;gBAAA;;cAAA;gBAAA,MAkBe,OAAOA,IAAP,KAAgB,WAlB/B;kBAAA;kBAAA;gBAAA;;gBAAA,MAmBY,IAAIM,SAAJ,CAAc,gCAAd,CAnBZ;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA,MAsBMyB,IAAI,YAAYI,WAAhB,IACC,OAAOC,iBAAP,KAA6B,WAA7B,IAA4CL,IAAI,YAAYK,iBAvBnE;kBAAA;kBAAA;gBAAA;;gBAwBUC,MAxBV,GAwBmBN,IAxBnB;gBAyBQO,UAzBR,GAyBqB,CAzBrB;gBA0BQC,UA1BR,GA0BqBR,IAAI,CAACQ,UA1B1B;;gBAAA,MA2BQ,OAAOvC,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IA3B7C;kBAAA;kBAAA;gBAAA;;gBA4BMG,OAAO,GAAGH,IAAV;gBA5BN;gBAAA;;cAAA;gBAAA,MA6Be,OAAOA,IAAP,KAAgB,QA7B/B;kBAAA;kBAAA;gBAAA;;gBA8BMsC,UAAU,GAAGtC,IAAb;;gBA9BN,IA+BWwC,MAAM,CAACC,aAAP,CAAqBH,UAArB,CA/BX;kBAAA;kBAAA;gBAAA;;gBAAA,MAgCc,IAAI1B,UAAJ,CAAe,oCAAf,CAhCd;;cAAA;gBAAA,MAkCU0B,UAAU,GAAG,CAAb,IAAkBA,UAAU,IAAID,MAAM,CAACE,UAlCjD;kBAAA;kBAAA;gBAAA;;gBAAA,MAmCc,IAAI3B,UAAJ,4CAAmDyB,MAAM,CAACE,UAA1D,QAnCd;;cAAA;gBAqCMA,UAAU,GAAGR,IAAI,CAACQ,UAAL,GAAkBD,UAA/B;;gBArCN,MAsCU,OAAOrC,IAAP,KAAgB,QAtC1B;kBAAA;kBAAA;gBAAA;;gBAuCQsC,UAAU,GAAGtC,IAAb;;gBAvCR,IAwCauC,MAAM,CAACC,aAAP,CAAqBF,UAArB,CAxCb;kBAAA;kBAAA;gBAAA;;gBAAA,MAyCgB,IAAI3B,UAAJ,CAAe,oCAAf,CAzChB;;cAAA;gBAAA,MA2CY2B,UAAU,IAAI,CAAd,IAAmBD,UAAU,GAAGC,UAAb,GAA0BF,MAAM,CAACE,UA3ChE;kBAAA;kBAAA;gBAAA;;gBAAA,MA4CgB,IAAI3B,UAAJ,4CAAmDyB,MAAM,CAACE,UAAP,GAAoBD,UAAvE,QA5ChB;;cAAA;gBAAA,MA8CY,OAAON,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IA9CjD;kBAAA;kBAAA;gBAAA;;gBA+CU7B,OAAO,GAAG6B,IAAV;gBA/CV;gBAAA;;cAAA;gBAAA,MAgDmB,OAAOA,IAAP,KAAgB,WAhDnC;kBAAA;kBAAA;gBAAA;;gBAAA,MAiDgB,IAAI1B,SAAJ,CAAc,gCAAd,CAjDhB;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA,MAmDiB,OAAOL,IAAP,KAAgB,WAnDjC;kBAAA;kBAAA;gBAAA;;gBAAA,MAoDc,IAAIK,SAAJ,CAAc,kCAAd,CApDd;;cAAA;gBAAA;gBAAA;;cAAA;gBAAA,MAsDe,OAAON,IAAP,KAAgB,WAtD/B;kBAAA;kBAAA;gBAAA;;gBAAA,MAuDY,IAAIM,SAAJ,CAAc,gCAAd,CAvDZ;;cAAA;gBAyDI2B,oBAAoB,GAAG,IAAIC,UAAJ,CAAeG,MAAf,EAAuBC,UAAvB,EAAmCC,UAAnC,CAAvB;gBAzDJ;gBAAA;;cAAA;gBAAA,MA2DU,IAAIjC,SAAJ,CAAc,yDAAd,CA3DV;;cAAA;gBA8DE;gBACMoC,GA/DR,GA+DcvC,OAAO,CAACwC,kBAAR,IAA8B,EA/D5C;gBAgEQC,YAhER,GAgEuBF,GAAG,CAACG,GAAJ,CAAQ,WAAC;kBAAA,OAAI,OAAOC,CAAP,KAAa,QAAb,GAAwBA,CAAxB,GAA4BA,CAAC,CAACrC,IAAlC;gBAAA,CAAT,CAhEvB;gBAAA;gBAAA,OAiEwBd,cAAc,CAACiD,YAAD,CAjEtC;;cAAA;gBAiEQG,OAjER;gBAAA;gBAAA,OAkEwBA,OAAO,CAACC,oBAAR,CAA6Bf,oBAA7B,EAAmD9B,OAAnD,CAlExB;;cAAA;gBAkEQL,OAlER;gBAAA,kCAmES,IAAID,gBAAJ,CAAqBC,OAArB,CAnET;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CA3GF;;MAAA;QAAA;MAAA;;MAAA;IAAA;EAAA;;EAAA;AAAA","names":["resolveBackend","Tensor","InferenceSession","handler","feeds","arg1","arg2","fetches","options","Array","isArray","TypeError","isFetchesEmpty","length","name","outputNames","indexOf","RangeError","isFetches","arg1Keys","Object","getOwnPropertyNames","v","inputNames","Error","run","results","returnValue","key","hasOwnProperty","call","type","data","dims","startProfiling","endProfiling","arg0","arg3","filePathOrUint8Array","Uint8Array","ArrayBuffer","SharedArrayBuffer","buffer","byteOffset","byteLength","Number","isSafeInteger","eps","executionProviders","backendHints","map","i","backend","createSessionHandler"],"sources":["/Users/nguyentrungchinh/project_20/node_modules/onnxruntime-common/lib/inference-session-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {SessionHandler} from './backend';\r\nimport {resolveBackend} from './backend-impl';\r\nimport {InferenceSession as InferenceSessionInterface} from './inference-session';\r\nimport {OnnxValue} from './onnx-value';\r\nimport {Tensor} from './tensor';\r\n\r\ntype SessionOptions = InferenceSessionInterface.SessionOptions;\r\ntype RunOptions = InferenceSessionInterface.RunOptions;\r\ntype FeedsType = InferenceSessionInterface.FeedsType;\r\ntype FetchesType = InferenceSessionInterface.FetchesType;\r\ntype ReturnType = InferenceSessionInterface.ReturnType;\r\n\r\nexport class InferenceSession implements InferenceSessionInterface {\r\n  private constructor(handler: SessionHandler) {\r\n    this.handler = handler;\r\n  }\r\n  run(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\r\n  run(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\r\n  async run(feeds: FeedsType, arg1?: FetchesType|RunOptions, arg2?: RunOptions): Promise<ReturnType> {\r\n    const fetches: {[name: string]: OnnxValue|null} = {};\r\n    let options: RunOptions = {};\r\n    // check inputs\r\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\r\n      throw new TypeError(\r\n          '\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\r\n    }\r\n\r\n    let isFetchesEmpty = true;\r\n    // determine which override is being used\r\n    if (typeof arg1 === 'object') {\r\n      if (arg1 === null) {\r\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\r\n      }\r\n      if (arg1 instanceof Tensor) {\r\n        throw new TypeError('\\'fetches\\' cannot be a Tensor');\r\n      }\r\n\r\n      if (Array.isArray(arg1)) {\r\n        if (arg1.length === 0) {\r\n          throw new TypeError('\\'fetches\\' cannot be an empty array.');\r\n        }\r\n        isFetchesEmpty = false;\r\n        // output names\r\n        for (const name of arg1) {\r\n          if (typeof name !== 'string') {\r\n            throw new TypeError('\\'fetches\\' must be a string array or an object.');\r\n          }\r\n          if (this.outputNames.indexOf(name) === -1) {\r\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\r\n          }\r\n          fetches[name] = null;\r\n        }\r\n\r\n        if (typeof arg2 === 'object' && arg2 !== null) {\r\n          options = arg2;\r\n        } else if (typeof arg2 !== 'undefined') {\r\n          throw new TypeError('\\'options\\' must be an object.');\r\n        }\r\n      } else {\r\n        // decide whether arg1 is fetches or options\r\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\r\n        let isFetches = false;\r\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\r\n        for (const name of this.outputNames) {\r\n          if (arg1Keys.indexOf(name) !== -1) {\r\n            const v = (arg1 as InferenceSessionInterface.NullableOnnxValueMapType)[name];\r\n            if (v === null || v instanceof Tensor) {\r\n              isFetches = true;\r\n              isFetchesEmpty = false;\r\n              fetches[name] = v;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (isFetches) {\r\n          if (typeof arg2 === 'object' && arg2 !== null) {\r\n            options = arg2;\r\n          } else if (typeof arg2 !== 'undefined') {\r\n            throw new TypeError('\\'options\\' must be an object.');\r\n          }\r\n        } else {\r\n          options = arg1 as RunOptions;\r\n        }\r\n      }\r\n    } else if (typeof arg1 !== 'undefined') {\r\n      throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\r\n    }\r\n\r\n    // check if all inputs are in feed\r\n    for (const name of this.inputNames) {\r\n      if (typeof feeds[name] === 'undefined') {\r\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\r\n      }\r\n    }\r\n\r\n    // if no fetches is specified, we use the full output names list\r\n    if (isFetchesEmpty) {\r\n      for (const name of this.outputNames) {\r\n        fetches[name] = null;\r\n      }\r\n    }\r\n\r\n    // feeds, fetches and options are prepared\r\n\r\n    const results = await this.handler.run(feeds, fetches, options);\r\n    const returnValue: {[name: string]: OnnxValue} = {};\r\n    for (const key in results) {\r\n      if (Object.hasOwnProperty.call(results, key)) {\r\n        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\r\n      }\r\n    }\r\n    return returnValue;\r\n  }\r\n\r\n  static create(path: string, options?: SessionOptions): Promise<InferenceSessionInterface>;\r\n  static create(buffer: ArrayBufferLike, options?: SessionOptions): Promise<InferenceSessionInterface>;\r\n  static create(buffer: ArrayBufferLike, byteOffset: number, byteLength?: number, options?: SessionOptions):\r\n      Promise<InferenceSessionInterface>;\r\n  static create(buffer: Uint8Array, options?: SessionOptions): Promise<InferenceSessionInterface>;\r\n  static async create(\r\n      arg0: string|ArrayBufferLike|Uint8Array, arg1?: SessionOptions|number, arg2?: number,\r\n      arg3?: SessionOptions): Promise<InferenceSessionInterface> {\r\n    // either load from a file or buffer\r\n    let filePathOrUint8Array: string|Uint8Array;\r\n    let options: SessionOptions = {};\r\n\r\n    if (typeof arg0 === 'string') {\r\n      filePathOrUint8Array = arg0;\r\n      if (typeof arg1 === 'object' && arg1 !== null) {\r\n        options = arg1;\r\n      } else if (typeof arg1 !== 'undefined') {\r\n        throw new TypeError('\\'options\\' must be an object.');\r\n      }\r\n    } else if (arg0 instanceof Uint8Array) {\r\n      filePathOrUint8Array = arg0;\r\n      if (typeof arg1 === 'object' && arg1 !== null) {\r\n        options = arg1;\r\n      } else if (typeof arg1 !== 'undefined') {\r\n        throw new TypeError('\\'options\\' must be an object.');\r\n      }\r\n    } else if (\r\n        arg0 instanceof ArrayBuffer ||\r\n        (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\r\n      const buffer = arg0;\r\n      let byteOffset = 0;\r\n      let byteLength = arg0.byteLength;\r\n      if (typeof arg1 === 'object' && arg1 !== null) {\r\n        options = arg1;\r\n      } else if (typeof arg1 === 'number') {\r\n        byteOffset = arg1;\r\n        if (!Number.isSafeInteger(byteOffset)) {\r\n          throw new RangeError('\\'byteOffset\\' must be an integer.');\r\n        }\r\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\r\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\r\n        }\r\n        byteLength = arg0.byteLength - byteOffset;\r\n        if (typeof arg2 === 'number') {\r\n          byteLength = arg2;\r\n          if (!Number.isSafeInteger(byteLength)) {\r\n            throw new RangeError('\\'byteLength\\' must be an integer.');\r\n          }\r\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\r\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\r\n          }\r\n          if (typeof arg3 === 'object' && arg3 !== null) {\r\n            options = arg3;\r\n          } else if (typeof arg3 !== 'undefined') {\r\n            throw new TypeError('\\'options\\' must be an object.');\r\n          }\r\n        } else if (typeof arg2 !== 'undefined') {\r\n          throw new TypeError('\\'byteLength\\' must be a number.');\r\n        }\r\n      } else if (typeof arg1 !== 'undefined') {\r\n        throw new TypeError('\\'options\\' must be an object.');\r\n      }\r\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\r\n    } else {\r\n      throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\r\n    }\r\n\r\n    // get backend hints\r\n    const eps = options.executionProviders || [];\r\n    const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\r\n    const backend = await resolveBackend(backendHints);\r\n    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\r\n    return new InferenceSession(handler);\r\n  }\r\n\r\n  startProfiling(): void {\r\n    this.handler.startProfiling();\r\n  }\r\n  endProfiling(): void {\r\n    this.handler.endProfiling();\r\n  }\r\n\r\n  get inputNames(): readonly string[] {\r\n    return this.handler.inputNames;\r\n  }\r\n  get outputNames(): readonly string[] {\r\n    return this.handler.outputNames;\r\n  }\r\n\r\n  private handler: SessionHandler;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}