{"ast":null,"code":"import _regeneratorRuntime from \"/Users/nguyentrungchinh/project_25/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/nguyentrungchinh/project_25/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/nguyentrungchinh/project_25/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar backends = {};\nvar backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\n\nexport var registerBackend = function registerBackend(name, backend, priority) {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    var currentBackend = backends[name];\n\n    if (currentBackend === undefined) {\n      backends[name] = {\n        backend: backend,\n        priority: priority\n      };\n    } else if (currentBackend.backend === backend) {\n      return;\n    } else {\n      throw new Error(\"backend \\\"\".concat(name, \"\\\" is already registered\"));\n    }\n\n    if (priority >= 0) {\n      for (var i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n\n      backendsSortedByPriority.push(name);\n    }\n\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\n\nexport var resolveBackend = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(backendHints) {\n    var backendNames, errors, _iterator, _step, backendName, backendInfo, isInitializing;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n            errors = [];\n            _iterator = _createForOfIteratorHelper(backendNames);\n            _context.prev = 3;\n\n            _iterator.s();\n\n          case 5:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 33;\n              break;\n            }\n\n            backendName = _step.value;\n            backendInfo = backends[backendName];\n\n            if (!backendInfo) {\n              _context.next = 31;\n              break;\n            }\n\n            if (!backendInfo.initialized) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.abrupt(\"return\", backendInfo.backend);\n\n          case 13:\n            if (!backendInfo.aborted) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 31);\n\n          case 15:\n            isInitializing = !!backendInfo.initPromise;\n            _context.prev = 16;\n\n            if (!isInitializing) {\n              backendInfo.initPromise = backendInfo.backend.init();\n            }\n\n            _context.next = 20;\n            return backendInfo.initPromise;\n\n          case 20:\n            backendInfo.initialized = true;\n            return _context.abrupt(\"return\", backendInfo.backend);\n\n          case 24:\n            _context.prev = 24;\n            _context.t0 = _context[\"catch\"](16);\n\n            if (!isInitializing) {\n              errors.push({\n                name: backendName,\n                err: _context.t0\n              });\n            }\n\n            backendInfo.aborted = true;\n\n          case 28:\n            _context.prev = 28;\n            delete backendInfo.initPromise;\n            return _context.finish(28);\n\n          case 31:\n            _context.next = 5;\n            break;\n\n          case 33:\n            _context.next = 38;\n            break;\n\n          case 35:\n            _context.prev = 35;\n            _context.t1 = _context[\"catch\"](3);\n\n            _iterator.e(_context.t1);\n\n          case 38:\n            _context.prev = 38;\n\n            _iterator.f();\n\n            return _context.finish(38);\n\n          case 41:\n            throw new Error(\"no available backend found. ERR: \".concat(errors.map(function (e) {\n              return \"[\".concat(e.name, \"] \").concat(e.err);\n            }).join(', ')));\n\n          case 42:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 35, 38, 41], [16, 24, 28, 31]]);\n  }));\n\n  return function resolveBackend(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"mappings":"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","names":["backends","backendsSortedByPriority","registerBackend","name","backend","priority","init","createSessionHandler","currentBackend","undefined","Error","i","length","splice","push","TypeError","resolveBackend","backendHints","backendNames","errors","backendName","backendInfo","initialized","aborted","isInitializing","initPromise","err","map","e","join"],"sources":["/Users/nguyentrungchinh/project_25/node_modules/onnxruntime-common/lib/backend-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {Backend} from './backend';\r\n\r\ninterface BackendInfo {\r\n  backend: Backend;\r\n  priority: number;\r\n\r\n  initPromise?: Promise<void>;\r\n  initialized?: boolean;\r\n  aborted?: boolean;\r\n}\r\n\r\nconst backends: {[name: string]: BackendInfo} = {};\r\nconst backendsSortedByPriority: string[] = [];\r\n\r\n/**\r\n * Register a backend.\r\n *\r\n * @param name - the name as a key to lookup as an execution provider.\r\n * @param backend - the backend object.\r\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\r\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\r\n *\r\n * @internal\r\n */\r\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\r\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\r\n    const currentBackend = backends[name];\r\n    if (currentBackend === undefined) {\r\n      backends[name] = {backend, priority};\r\n    } else if (currentBackend.backend === backend) {\r\n      return;\r\n    } else {\r\n      throw new Error(`backend \"${name}\" is already registered`);\r\n    }\r\n\r\n    if (priority >= 0) {\r\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\r\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\r\n          backendsSortedByPriority.splice(i, 0, name);\r\n          return;\r\n        }\r\n      }\r\n      backendsSortedByPriority.push(name);\r\n    }\r\n    return;\r\n  }\r\n\r\n  throw new TypeError('not a valid backend');\r\n};\r\n\r\n/**\r\n * Resolve backend by specified hints.\r\n *\r\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\r\n * @returns a promise that resolves to the backend.\r\n *\r\n * @internal\r\n */\r\nexport const resolveBackend = async(backendHints: readonly string[]): Promise<Backend> => {\r\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\r\n  const errors = [];\r\n  for (const backendName of backendNames) {\r\n    const backendInfo = backends[backendName];\r\n    if (backendInfo) {\r\n      if (backendInfo.initialized) {\r\n        return backendInfo.backend;\r\n      } else if (backendInfo.aborted) {\r\n        continue;  // current backend is unavailable; try next\r\n      }\r\n\r\n      const isInitializing = !!backendInfo.initPromise;\r\n      try {\r\n        if (!isInitializing) {\r\n          backendInfo.initPromise = backendInfo.backend.init();\r\n        }\r\n        await backendInfo.initPromise;\r\n        backendInfo.initialized = true;\r\n        return backendInfo.backend;\r\n      } catch (e) {\r\n        if (!isInitializing) {\r\n          errors.push({name: backendName, err: e});\r\n        }\r\n        backendInfo.aborted = true;\r\n      } finally {\r\n        delete backendInfo.initPromise;\r\n      }\r\n    }\r\n  }\r\n\r\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}