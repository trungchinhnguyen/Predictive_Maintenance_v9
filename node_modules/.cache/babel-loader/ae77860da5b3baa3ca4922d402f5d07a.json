{"ast":null,"code":"import _classCallCheck from \"/Users/nguyentrungchinh/project_19/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/nguyentrungchinh/project_19/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nvar isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function'; // a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\n\nvar NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([['float32', Float32Array], ['uint8', Uint8Array], ['int8', Int8Array], ['uint16', Uint16Array], ['int16', Int16Array], ['int32', Int32Array], ['bool', Uint8Array], ['float64', Float64Array], ['uint32', Uint32Array]]); // a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\n\nvar NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([[Float32Array, 'float32'], [Uint8Array, 'uint8'], [Int8Array, 'int8'], [Uint16Array, 'uint16'], [Int16Array, 'int16'], [Int32Array, 'int32'], [Float64Array, 'float64'], [Uint32Array, 'uint32']]);\n\nif (isBigInt64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\n\nif (isBigUint64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\n\n\nvar calculateSize = function calculateSize(dims) {\n  var size = 1;\n\n  for (var i = 0; i < dims.length; i++) {\n    var dim = dims[i];\n\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(\"dims[\".concat(i, \"] must be an integer, got: \").concat(dim));\n    }\n\n    if (dim < 0) {\n      throw new RangeError(\"dims[\".concat(i, \"] must be a non-negative integer, got: \").concat(dim));\n    }\n\n    size *= dim;\n  }\n\n  return size;\n};\n\nexport var Tensor = /*#__PURE__*/function () {\n  function Tensor(arg0, arg1, arg2) {\n    _classCallCheck(this, Tensor);\n\n    var type;\n    var data;\n    var dims; // check whether arg0 is type or data\n\n    if (typeof arg0 === 'string') {\n      //\n      // Override: constructor(type, data, ...)\n      //\n      type = arg0;\n      dims = arg2;\n\n      if (arg0 === 'string') {\n        // string tensor\n        if (!Array.isArray(arg1)) {\n          throw new TypeError('A string tensor\\'s data must be a string array.');\n        } // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n        // error will be populated at inference\n\n\n        data = arg1;\n      } else {\n        // numeric tensor\n        var typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n\n        if (typedArrayConstructor === undefined) {\n          throw new TypeError(\"Unsupported tensor type: \".concat(arg0, \".\"));\n        }\n\n        if (Array.isArray(arg1)) {\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n          // incorrect results.\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = typedArrayConstructor.from(arg1);\n        } else if (arg1 instanceof typedArrayConstructor) {\n          data = arg1;\n        } else {\n          throw new TypeError(\"A \".concat(type, \" tensor's data must be type of \").concat(typedArrayConstructor));\n        }\n      }\n    } else {\n      //\n      // Override: constructor(data, ...)\n      //\n      dims = arg1;\n\n      if (Array.isArray(arg0)) {\n        // only boolean[] and string[] is supported\n        if (arg0.length === 0) {\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\n        }\n\n        var firstElementType = typeof arg0[0];\n\n        if (firstElementType === 'string') {\n          type = 'string';\n          data = arg0;\n        } else if (firstElementType === 'boolean') {\n          type = 'bool'; // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n          // wrong type. We use 'as any' to make it happy.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          data = Uint8Array.from(arg0);\n        } else {\n          throw new TypeError(\"Invalid element type of data array: \".concat(firstElementType, \".\"));\n        }\n      } else {\n        // get tensor type from TypedArray\n        var mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n\n        if (mappedType === undefined) {\n          throw new TypeError(\"Unsupported type for tensor data: \".concat(arg0.constructor, \".\"));\n        }\n\n        type = mappedType;\n        data = arg0;\n      }\n    } // type and data is processed, now processing dims\n\n\n    if (dims === undefined) {\n      // assume 1-D tensor if dims omitted\n      dims = [data.length];\n    } else if (!Array.isArray(dims)) {\n      throw new TypeError('A tensor\\'s dims must be a number array');\n    } // perform check\n\n\n    var size = calculateSize(dims);\n\n    if (size !== data.length) {\n      throw new Error(\"Tensor's size(\".concat(size, \") does not match data length(\").concat(data.length, \").\"));\n    }\n\n    this.dims = dims;\n    this.type = type;\n    this.data = data;\n    this.size = size;\n  } //#endregion\n  //#region tensor utilities\n\n\n  _createClass(Tensor, [{\n    key: \"reshape\",\n    value: function reshape(dims) {\n      return new Tensor(this.type, this.data, dims);\n    }\n  }]);\n\n  return Tensor;\n}();","map":{"version":3,"mappings":"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","names":["isBigInt64ArrayAvailable","BigInt64Array","from","isBigUint64ArrayAvailable","BigUint64Array","NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP","Map","Float32Array","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Float64Array","Uint32Array","NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP","set","calculateSize","dims","size","i","length","dim","Number","isSafeInteger","TypeError","RangeError","Tensor","arg0","arg1","arg2","type","data","Array","isArray","typedArrayConstructor","get","undefined","firstElementType","mappedType","constructor","Error"],"sources":["/Users/nguyentrungchinh/project_19/node_modules/onnxruntime-common/lib/tensor-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {Tensor as TensorInterface} from './tensor';\r\n\r\ntype TensorType = TensorInterface.Type;\r\ntype TensorDataType = TensorInterface.DataType;\r\n\r\ntype SupportedTypedArrayConstructors = Float32ArrayConstructor|Uint8ArrayConstructor|Int8ArrayConstructor|\r\n    Uint16ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|Uint8ArrayConstructor|\r\n    Float64ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor;\r\ntype SupportedTypedArray = InstanceType<SupportedTypedArrayConstructors>;\r\n\r\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\r\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\r\n\r\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\r\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map<string, SupportedTypedArrayConstructors>([\r\n  ['float32', Float32Array],\r\n  ['uint8', Uint8Array],\r\n  ['int8', Int8Array],\r\n  ['uint16', Uint16Array],\r\n  ['int16', Int16Array],\r\n  ['int32', Int32Array],\r\n  ['bool', Uint8Array],\r\n  ['float64', Float64Array],\r\n  ['uint32', Uint32Array],\r\n]);\r\n\r\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\r\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map<SupportedTypedArrayConstructors, TensorType>([\r\n  [Float32Array, 'float32'],\r\n  [Uint8Array, 'uint8'],\r\n  [Int8Array, 'int8'],\r\n  [Uint16Array, 'uint16'],\r\n  [Int16Array, 'int16'],\r\n  [Int32Array, 'int32'],\r\n  [Float64Array, 'float64'],\r\n  [Uint32Array, 'uint32'],\r\n]);\r\n\r\nif (isBigInt64ArrayAvailable) {\r\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\r\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\r\n}\r\nif (isBigUint64ArrayAvailable) {\r\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\r\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\r\n}\r\n\r\n/**\r\n * calculate size from dims.\r\n *\r\n * @param dims the dims array. May be an illegal input.\r\n */\r\nconst calculateSize = (dims: readonly unknown[]): number => {\r\n  let size = 1;\r\n  for (let i = 0; i < dims.length; i++) {\r\n    const dim = dims[i];\r\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\r\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\r\n    }\r\n    if (dim < 0) {\r\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\r\n    }\r\n    size *= dim;\r\n  }\r\n  return size;\r\n};\r\n\r\nexport class Tensor implements TensorInterface {\r\n  //#region constructors\r\n  constructor(type: TensorType, data: TensorDataType|readonly number[]|readonly boolean[], dims?: readonly number[]);\r\n  constructor(data: TensorDataType|readonly boolean[], dims?: readonly number[]);\r\n  constructor(\r\n      arg0: TensorType|TensorDataType|readonly boolean[], arg1?: TensorDataType|readonly number[]|readonly boolean[],\r\n      arg2?: readonly number[]) {\r\n    let type: TensorType;\r\n    let data: TensorDataType;\r\n    let dims: typeof arg1|typeof arg2;\r\n    // check whether arg0 is type or data\r\n    if (typeof arg0 === 'string') {\r\n      //\r\n      // Override: constructor(type, data, ...)\r\n      //\r\n      type = arg0;\r\n      dims = arg2;\r\n      if (arg0 === 'string') {\r\n        // string tensor\r\n        if (!Array.isArray(arg1)) {\r\n          throw new TypeError('A string tensor\\'s data must be a string array.');\r\n        }\r\n        // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\r\n        // error will be populated at inference\r\n        data = arg1;\r\n      } else {\r\n        // numeric tensor\r\n        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\r\n        if (typedArrayConstructor === undefined) {\r\n          throw new TypeError(`Unsupported tensor type: ${arg0}.`);\r\n        }\r\n        if (Array.isArray(arg1)) {\r\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\r\n          // incorrect results.\r\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          data = (typedArrayConstructor as any).from(arg1);\r\n        } else if (arg1 instanceof typedArrayConstructor) {\r\n          data = arg1;\r\n        } else {\r\n          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\r\n        }\r\n      }\r\n    } else {\r\n      //\r\n      // Override: constructor(data, ...)\r\n      //\r\n      dims = arg1;\r\n      if (Array.isArray(arg0)) {\r\n        // only boolean[] and string[] is supported\r\n        if (arg0.length === 0) {\r\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\r\n        }\r\n        const firstElementType = typeof arg0[0];\r\n        if (firstElementType === 'string') {\r\n          type = 'string';\r\n          data = arg0;\r\n        } else if (firstElementType === 'boolean') {\r\n          type = 'bool';\r\n          // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\r\n          // wrong type. We use 'as any' to make it happy.\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          data = Uint8Array.from(arg0 as any[]);\r\n        } else {\r\n          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\r\n        }\r\n      } else {\r\n        // get tensor type from TypedArray\r\n        const mappedType =\r\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor as SupportedTypedArrayConstructors);\r\n        if (mappedType === undefined) {\r\n          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\r\n        }\r\n        type = mappedType;\r\n        data = arg0 as SupportedTypedArray;\r\n      }\r\n    }\r\n\r\n    // type and data is processed, now processing dims\r\n    if (dims === undefined) {\r\n      // assume 1-D tensor if dims omitted\r\n      dims = [data.length];\r\n    } else if (!Array.isArray(dims)) {\r\n      throw new TypeError('A tensor\\'s dims must be a number array');\r\n    }\r\n\r\n    // perform check\r\n    const size = calculateSize(dims);\r\n    if (size !== data.length) {\r\n      throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\r\n    }\r\n\r\n    this.dims = dims as readonly number[];\r\n    this.type = type;\r\n    this.data = data;\r\n    this.size = size;\r\n  }\r\n  //#endregion\r\n\r\n  //#region fields\r\n  readonly dims: readonly number[];\r\n  readonly type: TensorType;\r\n  readonly data: TensorDataType;\r\n  readonly size: number;\r\n  //#endregion\r\n\r\n  //#region tensor utilities\r\n  reshape(dims: readonly number[]): Tensor {\r\n    return new Tensor(this.type, this.data, dims);\r\n  }\r\n  //#endregion\r\n}\r\n"]},"metadata":{},"sourceType":"module"}